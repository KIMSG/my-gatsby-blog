{"componentChunkName":"component---src-templates-blog-post-js","path":"/리액트의렌더링/","result":{"data":{"site":{"siteMetadata":{"title":"모던리액트딥다이브 스터디를 하고 있습니다."}},"markdownRemark":{"id":"cdb64b3f-0ed1-5e27-8f8f-c6dd7b2b69a1","excerpt":"1. 렌더링(Rendering)이란? 화면(UI)을 그리는 과정\r\n리액트가 여러분의 컴포넌트(함수나 클래스)를 바탕으로 실제 브라우저 화면에 보이는 HTML 요소를 만들어 내는 일을 “렌더링”이라고 해요. “처음 그리기” vs…","html":"<hr>\n<h2>1. 렌더링(Rendering)이란?</h2>\n<ul>\n<li>\n<p><strong>화면(UI)을 그리는 과정</strong>\r\n리액트가 여러분의 컴포넌트(함수나 클래스)를 바탕으로 실제 브라우저 화면에 보이는 HTML 요소를 만들어 내는 일을 “렌더링”이라고 해요.</p>\n</li>\n<li>\n<p><strong>“처음 그리기” vs “다시 그리기”</strong></p>\n<ul>\n<li><strong>초기 렌더링</strong>: 앱이 처음 켜질 때 전체 화면을 그려요.</li>\n<li><strong>업데이트 렌더링</strong>: 버튼 클릭, 입력값 변화 등으로 <strong>state</strong>나 <strong>props</strong>가 바뀌면, 그 바뀐 부분만 다시 그려요.</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2>2. 초기 렌더링 과정</h2>\n<ol>\n<li>\n<p><strong>JSX → React Element</strong>\r\nJSX(<code class=\"language-text\">&lt;div>Hello&lt;/div></code>)를 브라우저가 이해할 수 있는 객체 형태(<code class=\"language-text\">React.createElement</code>)로 변환해요.</p>\n</li>\n<li>\n<p><strong>Virtual DOM 생성</strong>\r\n메모리(가상 공간)에 브라우저 DOM 구조와 똑같은 나무 구조(트리)를 만들어요.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">App\r\n├─ Header\r\n└─ Main\r\n   ├─ PostList\r\n   └─ Sidebar</code></pre></div>\n</li>\n<li>\n<p><strong>실제 DOM 생성 &#x26; 화면 표시</strong>\r\nVirtual DOM 트리를 실제 DOM 트리(HTML 요소들)로 한 번에 만들어 브라우저에 붙여요.</p>\n</li>\n</ol>\n<hr>\n<h2>3. 업데이트 렌더링 과정</h2>\n<p>예시 코드:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\r\n\r\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>버튼을 클릭하면 <code class=\"language-text\">setCount</code>가 실행되고, <strong>state</strong>가 바뀌면서 다시 렌더링이 일어나요.</p>\n<ol>\n<li>\n<p><strong>state/props 변경 감지</strong>\r\n<code class=\"language-text\">setCount(1)</code> 처럼 값이 바뀌면 리액트가 “다시 렌더링해야겠다!”고 표시(mark)해둬요.</p>\n</li>\n<li>\n<p><strong>새로운 Virtual DOM 생성</strong>\r\n변경된 값을 반영해 함수 컴포넌트를 다시 호출하고, <strong>새로운 Virtual DOM</strong>을 만들어요.</p>\n</li>\n<li>\n<p><strong>이전 Virtual DOM과 비교(diff)</strong>\r\n두 트리를 나란히 비교해서 “어디가 달라졌는지”를 찾아요.\r\n──> 이 과정을 <strong>Reconciliation</strong>(조정)이라고 부릅니다.</p>\n</li>\n<li>\n<p><strong>실제 DOM 업데이트</strong>\r\n비교 결과, 실제 브라우저 화면 중 <strong>변경이 필요한 최소한의 부분</strong>만 실제 DOM에 반영해요.\r\n(여기서는 버튼 텍스트 숫자만 0→1로 업데이트)</p>\n</li>\n</ol>\n<hr>\n<h2>4. Virtual DOM과 실제 DOM</h2>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>Virtual DOM</th>\n<th>실제 DOM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>위치</td>\n<td>자바스크립트 메모리(가상 트리)</td>\n<td>브라우저 내부 메모리</td>\n</tr>\n<tr>\n<td>생성/비교 속도</td>\n<td>빠름</td>\n<td>느림</td>\n</tr>\n<tr>\n<td>업데이트 방식</td>\n<td>전체 트리 생성 후 비교(diff)</td>\n<td>변경된 부분만 직접 조작</td>\n</tr>\n<tr>\n<td>목적</td>\n<td>효율적인 화면 갱신</td>\n<td>최종 사용자에게 보여주는 실제 화면</td>\n</tr>\n</tbody>\n</table>\n<p><strong>비유</strong>:</p>\n<ul>\n<li>Virtual DOM은 <strong>설계도</strong>(Blueprint)</li>\n<li>실제 DOM은 <strong>집(건물)</strong></li>\n<li>설계도를 여러 번 바꿔보면서(비교) 실제 공사를 최소한으로 하는 것과 같아요.</li>\n</ul>\n<hr>\n<h2>5. 렌더링이 일어나는 시점</h2>\n<ul>\n<li>컴포넌트가 <strong>처음 마운트</strong>(mount)될 때</li>\n<li><strong>props</strong>가 부모로부터 변경되어 전달될 때</li>\n<li><strong>state</strong>가 <code class=\"language-text\">setState</code>/<code class=\"language-text\">useState</code>로 업데이트될 때</li>\n<li>부모 컴포넌트가 렌더링되어 자식도 함께 호출될 때</li>\n</ul>\n<blockquote>\n<p><strong>Tip</strong>: <code class=\"language-text\">React.memo</code>, <code class=\"language-text\">PureComponent</code> 등을 쓰면 <strong>props</strong>가 실제로 바뀌지 않았으면 리렌더링을 건너뛸 수 있어요.</p>\n</blockquote>\n<hr>\n<h2>6. 요약</h2>\n<ol>\n<li>\n<p><strong>JSX → React Element → Virtual DOM</strong></p>\n</li>\n<li>\n<p><strong>초기 렌더링</strong>: Virtual DOM → 실제 DOM</p>\n</li>\n<li>\n<p><strong>업데이트 렌더링</strong>:</p>\n<ul>\n<li>state/props 변경 → 새로운 Virtual DOM</li>\n<li>이전 Virtual DOM과 diff → 최소한의 실제 DOM 업데이트</li>\n</ul>\n</li>\n<li>\n<p>Virtual DOM 덕분에 <strong>빠르게</strong>, <strong>효율적으로</strong> 사용자 화면이 갱신돼요.</p>\n</li>\n</ol>\n<p>이제 “Virtual DOM을 만들고, 비교하고, 필요한 최소한만 실제 화면에 그린다”는 흐름만 머릿속에 그려보세요. 그러면 리액트 렌더링의 큰 그림이 잡힐 거예요!</p>\n<h2>7. 게으른 초기화(lazy initialization)</h2>\n<p><code class=\"language-text\">useState</code> 훅을 사용할 때 <strong>초기값을 계산하는 비용이 클 경우</strong>, <strong>최초 렌더링 시에만 해당 값을 계산</strong>하도록 하기 위한 최적화 기법이에요.</p>\n<h3>✅ 기본 개념</h3>\n<p><code class=\"language-text\">useState</code>는 다음 두 가지 방식으로 사용할 수 있어요:</p>\n<h4>1. <strong>즉시 실행 방식</strong></h4>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token function\">expensiveFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>컴포넌트가 <strong>렌더링될 때마다</strong> <code class=\"language-text\">expensiveFunction()</code>이 실행됨\r\n→ 비효율적일 수 있어요.</li>\n</ul>\n<h4>2. <strong>게으른 초기화 방식 (Lazy Initialization)</strong></h4>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>value<span class=\"token punctuation\">,</span> setValue<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">expensiveFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">expensiveFunction</code>은 <strong>처음 렌더링할 때 딱 한 번만 실행</strong>됨</li>\n<li>그 이후로는 상태가 변할 때만 렌더링되고, <code class=\"language-text\">expensiveFunction()</code>은 다시 실행되지 않음</li>\n</ul>\n<hr>\n<h3>🧠 언제 쓰면 좋을까?</h3>\n<ul>\n<li>초기값을 <strong>계산하는 데 시간이 오래 걸리는 경우</strong></li>\n<li>예: JSON 파싱, 복잡한 계산, 캐시에서 값 불러오기 등</li>\n</ul>\n<hr>\n<h3>📌 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">App</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\r\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>user<span class=\"token punctuation\">,</span> setUser<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\r\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"초기화 중...\"</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">const</span> saved <span class=\"token operator\">=</span> localStorage<span class=\"token punctuation\">.</span><span class=\"token function\">getItem</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"user\"</span><span class=\"token punctuation\">)</span>\r\n    <span class=\"token keyword\">return</span> saved <span class=\"token operator\">?</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>saved<span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span>\r\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\r\n\r\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>user <span class=\"token operator\">?</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Hello, </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>user<span class=\"token punctuation\">.</span>name<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span> <span class=\"token operator\">:</span> <span class=\"token string\">\"로그인 필요\"</span><span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>👉 이렇게 하면 <strong>localStorage 접근과 JSON 파싱을 처음 렌더링할 때 한 번만 실행</strong>하게 돼요.</p>","frontmatter":{"title":"React의 렌더링 과정을 파악하자","date":"May 23, 2025","description":"React의 렌더링 과정을 한눈에 파악할 수 있도록, 최대한 쉬운 말과 단계별 흐름으로 설명해볼게요."}},"previous":{"fields":{"slug":"/DOM이용하기/"},"frontmatter":{"title":"가상 DOM(Virtual DOM)"}},"next":{"fields":{"slug":"/리액트HOOK/"},"frontmatter":{"title":"리액트 Hook 중 가장 기본"}}},"pageContext":{"id":"cdb64b3f-0ed1-5e27-8f8f-c6dd7b2b69a1","previousPostId":"d9bff85d-455b-5e4e-9388-2103588ef4a6","nextPostId":"93186cf0-0238-52ae-946e-c34e6b15e9b3"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}