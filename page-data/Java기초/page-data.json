{"componentChunkName":"component---src-templates-blog-post-js","path":"/Java기초/","result":{"data":{"site":{"siteMetadata":{"title":"모던리액트딥다이브 스터디를 하고 있습니다."}},"markdownRemark":{"id":"4985cca8-49eb-58cd-aea6-ae8d740e7aa8","excerpt":"Phase 1. 언어 & 실행 환경 이해 1. JVM · JDK · JRE 개요 목표: 자바 프로그램이 어떻게 실행되는지, JDK/JRE/JVM의 역할을 명확히 이해 주요 내용: 클래스 로딩 과정, 바이트코드 → JIT 컴파일, 메모리 구조(Heap, Stack, Method Area…","html":"<hr>\n<h2>Phase 1. 언어 &#x26; 실행 환경 이해</h2>\n<h3>1. JVM · JDK · JRE 개요</h3>\n<ul>\n<li><strong>목표</strong>: 자바 프로그램이 어떻게 실행되는지, JDK/JRE/JVM의 역할을 명확히 이해</li>\n<li><strong>주요 내용</strong>: 클래스 로딩 과정, 바이트코드 → JIT 컴파일, 메모리 구조(Heap, Stack, Method Area)</li>\n</ul>\n<h4>왜 존재하는가?</h4>\n<ul>\n<li><strong>플랫폼 독립성의 핵심, JVM</strong>\n<ul>\n<li>“한 번 작성하면 어디서나 실행한다(Write Once, Run Anywhere)” 보장</li>\n<li>소스코드 → 바이트코드 → JVM에서 해석·실행</li>\n</ul>\n</li>\n<li><strong>개발 도구의 집합, JDK</strong>\n<ul>\n<li><code class=\"language-text\">javac</code>, <code class=\"language-text\">jar</code>, <code class=\"language-text\">javadoc</code>, <code class=\"language-text\">jdb</code>, <code class=\"language-text\">jdeps</code> 등</li>\n<li>내부에 JRE 포함 → 컴파일 후 즉시 실행 가능</li>\n</ul>\n</li>\n<li><strong>실행 환경만 담은, JRE</strong>\n<ul>\n<li>JVM + 표준 라이브러리</li>\n<li>실행만 필요할 때 JDK 없이 JRE만으로 충분</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>2. JDK · JRE · JVM 관계</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    ┌────────────────────────────┐\r\n    │        개발자(You)         │\r\n    └─────────────┬──────────────┘\r\n                  │\r\n                  ▼\r\n    ┌────────────────────────────┐\r\n    │           JDK 24           │\r\n    │  - javac (컴파일러)        │\r\n    │  - jar, javadoc, jdb 등    │\r\n    │  - 내부에 JRE 포함         │\r\n    └─────────────┬──────────────┘\r\n                  │\r\n        (실행만 할 땐 ↓ JRE만)\r\n                  ▼\r\n    ┌────────────────────────────┐\r\n    │           JRE             │\r\n    │  - JVM (실행 엔진)        │\r\n    │  - 표준 라이브러리         │\r\n    └─────────────┬──────────────┘\r\n                  │\r\n        (플랫폼별 구현체 ↓)\r\n                  ▼\r\n    ┌────────────────────────────┐\r\n    │           JVM             │\r\n    │  - 클래스 로딩             │\r\n    │  - 바이트코드 해석/실행    │\r\n    │  - 메모리 관리, GC 등      │\r\n    └────────────────────────────┘</code></pre></div>\n<table>\n<thead>\n<tr>\n<th align=\"center\">구성 요소</th>\n<th align=\"left\">역할</th>\n<th align=\"left\">포함 내용</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><strong>JDK</strong></td>\n<td align=\"left\">개발 → 컴파일 → 디버깅까지 모두 제공</td>\n<td align=\"left\">javac, jar, javadoc, JRE</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>JRE</strong></td>\n<td align=\"left\">이미 컴파일된 자바 애플리케이션 ‘실행’ 전용</td>\n<td align=\"left\">JVM, 표준 라이브러리</td>\n</tr>\n<tr>\n<td align=\"center\"><strong>JVM</strong></td>\n<td align=\"left\">바이트코드를 네이티브 코드로 실행하는 가상 머신</td>\n<td align=\"left\">인터프리터, JIT, GC, ClassLoader</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3>3. 클래스 로딩 과정</h3>\n<p>자바 애플리케이션 실행 시 <code class=\"language-text\">.class</code> 파일이 JVM 내부로 어떻게 들어오는지 세 단계로 나누어 살펴봅니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ .java 파일 ]\r\n       ↓ javac\r\n[ .class 파일 (바이트코드) ]\r\n       ↓\r\n┌──────────────────────────────────────┐\r\n│ 1) Loading (로딩)                   │\r\n│   - ClassLoader가 .class를 읽어옴   │\r\n│   - Bootstrap → Extension → App     │\r\n└──────────────────────────────────────┘\r\n       ↓\r\n┌──────────────────────────────────────┐\r\n│ 2) Linking (링킹)                   │\r\n│   a. Verification (검증)            │\r\n│   b. Preparation (할당, 기본값)      │\r\n│   c. Resolution (심볼릭→실제 참조)  │\r\n└──────────────────────────────────────┘\r\n       ↓\r\n┌──────────────────────────────────────┐\r\n│ 3) Initialization (초기화)          │\r\n│   - static 블록, static 필드 초기화 │\r\n└──────────────────────────────────────┘</code></pre></div>\n<ol>\n<li>\n<p><strong>Loading</strong></p>\n<ul>\n<li><code class=\"language-text\">ClassLoader</code>가 <code class=\"language-text\">.class</code> 파일을 찾아 메모리에 로드</li>\n<li>Parent Delegation: Bootstrap → Extension → Application 순으로 위임</li>\n</ul>\n</li>\n<li>\n<p><strong>Linking</strong></p>\n<ul>\n<li><strong>Verification</strong>: 바이트코드 안전성 검사</li>\n<li><strong>Preparation</strong>: static 필드 기본값 할당</li>\n<li><strong>Resolution</strong>: 심볼릭 레퍼런스를 실제 참조로 변경</li>\n</ul>\n</li>\n<li>\n<p><strong>Initialization</strong></p>\n<ul>\n<li><code class=\"language-text\">static</code> 초기화 블록 및 필드 초기화 실행</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>4. 바이트코드 → 네이티브 코드 실행</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[ 바이트코드 (.class) ]\r\n         ↓\r\n┌──────────────────┐\r\n│ Interpreter      │\r\n│ (한 줄씩 해석)    │\r\n└──────────────────┘\r\n         │\r\n(핫스팟 감지: 호출 빈도↑)\r\n         ↓\r\n┌──────────────────┐\r\n│    JIT Compiler  │\r\n│ • C1 (빠른 컴파일)│\r\n│ • C2 (강력 최적화)│\r\n└──────────────────┘\r\n         ↓\r\n[ 네이티브 기계어 (실행 속도↑) ]</code></pre></div>\n<ul>\n<li>\n<p><strong>Interpreter</strong>: 바이트코드를 한 줄씩 해석</p>\n</li>\n<li>\n<p><strong>JIT Compiler</strong>: 자주 실행되는 코드를 런타임에 네이티브 코드로 변환</p>\n<ul>\n<li><code class=\"language-text\">-XX:+PrintCompilation</code> 옵션으로 컴파일 시점 로그 확인 가능</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h3>5. JVM 메모리 구조</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[Method Area/Metaspace]   ← 클래스 코드·정적 변수\r\n         │\r\n  ┌──────▼───────┐\r\n  │     Heap     │\r\n  │ ┌───┐  ┌─────┐│\r\n  │ │ E │→─│Old  ││\r\n  │ │ d │  │Gen  ││\r\n  │ │ e │  │     ││\r\n  │ └───┘  └─────┘│\r\n  └──────┬────────┘\r\n         │\r\n  ┌──────▼────────┐\r\n  │  Java Stack   │\r\n  │ (프레임별 로컬  │\r\n  │  변수·연산 스택)│\r\n  └──────┬────────┘\r\n         │\r\n  ┌──────▼────────┐\r\n  │ Native Stack  │\r\n  │ &amp; PC Register │\r\n  └───────────────┘</code></pre></div>\n<ul>\n<li>\n<p><strong>Method Area (Metaspace)</strong>: 클래스 메타데이터, static 변수, 상수 풀</p>\n</li>\n<li>\n<p><strong>Heap</strong></p>\n<ul>\n<li><strong>Young Gen</strong>: Eden → Survivor0/1</li>\n<li><strong>Old Gen</strong>: 장기 생존 객체</li>\n</ul>\n</li>\n<li>\n<p><strong>Java Stack</strong>: 스레드별 호출 프레임(로컬 변수·연산 스택)</p>\n</li>\n<li>\n<p><strong>Native Method Stack &#x26; PC Register</strong>: JNI 호출, 현재 실행 위치</p>\n</li>\n</ul>\n<hr>\n<h3>6. 개발 환경 설정</h3>\n<ol>\n<li>\n<p><strong>JDK 24 설치 &#x26; 환경변수</strong></p>\n<ul>\n<li><code class=\"language-text\">JAVA_HOME</code> → JDK 설치 경로</li>\n<li><code class=\"language-text\">PATH</code>에 <code class=\"language-text\">$JAVA_HOME/bin</code> 추가</li>\n</ul>\n</li>\n<li>\n<p><strong>빌드 도구: Maven vs. Gradle</strong></p>\n<ul>\n<li><strong>Maven</strong>: XML(<code class=\"language-text\">pom.xml</code>) 중심, 표준 라이프사이클</li>\n<li><strong>Gradle</strong>: Groovy/Kotlin DSL, 스크립트 유연성</li>\n</ul>\n</li>\n<li>\n<p><strong>IDE(IntelliJ IDEA) 워크플로우</strong></p>\n<ol>\n<li>New Project → SDK(Java 24) + Build Tool 선택</li>\n<li><code class=\"language-text\">src/main/java</code>, <code class=\"language-text\">src/test/java</code> 구조 확인</li>\n<li>의존성 추가 → 자동 다운로드</li>\n<li>코드 작성 → 자동 완성·인스펙션 활용</li>\n<li>실행/디버그 구성(Configuration) 생성</li>\n</ol>\n</li>\n<li>\n<p><strong>디버깅 개념</strong></p>\n<ul>\n<li>Breakpoint → JVM 일시 정지</li>\n<li>Step Into/Over/Out → 코드 흐름 추적</li>\n<li>Variables/Watch → 변수 상태 관찰</li>\n<li>Remote Debug → <code class=\"language-text\">-agentlib:jdwp=…</code> 옵션으로 원격 연결</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>7. 워크플로우 개념도</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[프로젝트 생성]\r\n  IntelliJ IDEA → New Project\r\n    ├─ SDK: Java 24\r\n    ├─ Build Tool: Maven/Gradle\r\n    └─ Folder Structure 자동 생성\r\n          src/main/java\r\n          src/test/java\r\n\r\n      ↓\r\n\r\n[코드 작성]\r\n  - 자동 완성·인스펙션 활용\r\n  - 의존성 추가 → 자동 다운로드\r\n\r\n      ↓\r\n\r\n[빌드 &amp; 실행]\r\n  Maven: mvn clean compile exec:java\r\n  Gradle: gradle clean build run\r\n\r\n      ↓\r\n\r\n[디버깅]\r\n  - Breakpoint 설정\r\n  - ▶▶(Debug) → Step Into/Over/Out\r\n  - Variables 창에서 상태 확인\r\n\r\n      ↓\r\n\r\n[배포]\r\n  - JAR/WAR 패키징 → 운영 서버에 배포</code></pre></div>\n<hr>\n<h2>Phase 2. 문법 &#x26; 제어 흐름</h2>\n<ol start=\"3\">\n<li>\n<p><strong>기본 자료형 &#x26; 변수</strong></p>\n<ul>\n<li><strong>목표</strong>: 모든 타입의 차이(primitive vs reference)와 메모리 모델 이해</li>\n<li><strong>주요 내용</strong>: boolean, byte, char, short, int, long, float, double; 변수 스코프; 리터럴</li>\n</ul>\n</li>\n<li>\n<p><strong>연산자와 제어문</strong></p>\n<ul>\n<li><strong>목표</strong>: 모든 연산자 우선순위와 제어문 흐름 파악</li>\n<li><strong>주요 내용</strong>: 산술·비교·논리·할당 연산자, if-else, switch, for/while, break·continue</li>\n</ul>\n</li>\n<li>\n<p><strong>메서드 &#x26; 패키지</strong></p>\n<ul>\n<li><strong>목표</strong>: 메서드 호출 규칙, 오버로딩/가변인자 문법, 패키지 구조 이해</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">static</code> vs 인스턴스 메서드, 리턴타입, 접근 제한자, import</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Phase 3. 객체지향 프로그래밍</h2>\n<ol start=\"6\">\n<li>\n<p><strong>클래스와 객체</strong></p>\n<ul>\n<li><strong>목표</strong>: 클래스로 현실 세계 모델링하기</li>\n<li><strong>주요 내용</strong>: 필드·메서드·생성자, <code class=\"language-text\">this</code>, <code class=\"language-text\">final</code> 클래스/메서드/변수</li>\n</ul>\n</li>\n<li>\n<p><strong>상속(Inheritance) &#x26; 다형성(Polymorphism)</strong></p>\n<ul>\n<li><strong>목표</strong>: 코드 재사용과 유연성 극대화</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">extends</code>/<code class=\"language-text\">super</code>, 오버라이딩 vs 오버로딩, 업캐스팅·다운캐스팅</li>\n</ul>\n</li>\n<li>\n<p><strong>추상화(Abstraction) &#x26; 인터페이스(Interface)</strong></p>\n<ul>\n<li><strong>목표</strong>: 설계 시 느슨한 결합(loose coupling) 달성</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">abstract</code> 클래스, 인터페이스 기본/디폴트/정적 메서드, 다중 구현</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Phase 4. 표준 라이브러리 활용</h2>\n<ol start=\"9\">\n<li>\n<p><strong>기본 API 클래스</strong></p>\n<ul>\n<li><strong>목표</strong>: 자주 쓰는 유틸리티 클래스 능숙 사용</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">String</code>/<code class=\"language-text\">StringBuilder</code>, 래퍼 클래스, <code class=\"language-text\">Math</code>, <code class=\"language-text\">java.time</code> 패키지</li>\n</ul>\n</li>\n<li>\n<p><strong>컬렉션 프레임워크</strong></p>\n<ul>\n<li><strong>목표</strong>: 자료구조 특성에 맞는 구조 선택</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">List</code>(ArrayList, LinkedList), <code class=\"language-text\">Set</code>(HashSet, TreeSet), <code class=\"language-text\">Map</code>(HashMap, TreeMap), <code class=\"language-text\">Iterator</code></li>\n</ul>\n</li>\n<li>\n<p><strong>제네릭(Generics)</strong></p>\n<ul>\n<li><strong>목표</strong>: 타입 안전성과 재사용성 확보</li>\n<li><strong>주요 내용</strong>: 제네릭 클래스/메서드, 와일드카드(<code class=\"language-text\">? extends</code>, <code class=\"language-text\">? super</code>), 타입 소거(type erasure)</li>\n</ul>\n</li>\n<li>\n<p><strong>람다식 &#x26; 스트림(Stream API)</strong></p>\n<ul>\n<li><strong>목표</strong>: 함수형 프로그래밍 기초 이해</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">Function</code>, <code class=\"language-text\">Consumer</code>, <code class=\"language-text\">Predicate</code> 인터페이스, <code class=\"language-text\">stream()</code> → <code class=\"language-text\">filter</code>·<code class=\"language-text\">map</code>·<code class=\"language-text\">reduce</code></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Phase 5. 예외·I/O·동시성</h2>\n<ol start=\"13\">\n<li>\n<p><strong>예외 처리(Exception Handling)</strong></p>\n<ul>\n<li><strong>목표</strong>: 안정적인 오류 관리</li>\n<li><strong>주요 내용</strong>: Checked vs Unchecked, <code class=\"language-text\">try-catch-finally</code>, <code class=\"language-text\">throws</code>, 사용자 정의 예외</li>\n</ul>\n</li>\n<li>\n<p><strong>입출력 스트림(I/O &#x26; NIO)</strong></p>\n<ul>\n<li><strong>목표</strong>: 파일·네트워크 데이터 입출력 원리 완전 정복</li>\n<li><strong>주요 내용</strong>: 바이트 vs 문자 스트림, <code class=\"language-text\">BufferedReader</code>/<code class=\"language-text\">BufferedWriter</code>, NIO <code class=\"language-text\">Channel</code>·<code class=\"language-text\">Buffer</code></li>\n</ul>\n</li>\n<li>\n<p><strong>멀티스레딩 &#x26; 동시성(Concurrency)</strong></p>\n<ul>\n<li><strong>목표</strong>: 안전한 동시성 프로그래밍</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">Thread</code>·<code class=\"language-text\">Runnable</code>, <code class=\"language-text\">synchronized</code>, <code class=\"language-text\">Lock</code> 인터페이스, <code class=\"language-text\">ExecutorService</code></li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Phase 6. JVM 심화 &#x26; 부가 개념</h2>\n<ol start=\"16\">\n<li>\n<p><strong>JVM 메모리 모델 &#x26; GC</strong></p>\n<ul>\n<li><strong>목표</strong>: 성능 최적화와 메모리 문제 해결 기반 마련</li>\n<li><strong>주요 내용</strong>: Young/Old Generation, GC 알고리듬(G1, Serial, Parallel)</li>\n</ul>\n</li>\n<li>\n<p><strong>리플렉션(Reflection) &#x26; 애노테이션(Annotation)</strong></p>\n<ul>\n<li><strong>목표</strong>: 프레임워크 동작 원리(예: 스프링 DI) 이해</li>\n<li><strong>주요 내용</strong>: <code class=\"language-text\">Class</code> 객체, <code class=\"language-text\">getMethod</code>·<code class=\"language-text\">invoke</code>, 커스텀 애노테이션, 애노테이션 처리</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3>📌 학습 가이드</h3>\n<ul>\n<li>\n<p><strong>매 모듈마다</strong>:</p>\n<ol>\n<li>핵심 개념 정리</li>\n<li>작은 예제 코드 작성</li>\n<li>연습 문제(알고리즘 + 설계 과제) 해결</li>\n</ol>\n</li>\n<li>\n<p><strong>매주 복습</strong>: 이전 모듈 핵심 키워드 퀴즈 &#x26; 코드 리팩토링</p>\n</li>\n<li>\n<p><strong>최종 프로젝트</strong>: 순수 Java로 간단 ‘도서 관리 시스템’ 등을 만들어 보며 전체 흐름 점검</p>\n</li>\n</ul>","frontmatter":{"title":"#java 0. 자바 “기초”에 집중","date":"May 23, 2024","description":"오로지 자바 “기초”에 집중해 완벽한 이해를 돕기 위해 재구성한 커리큘럼입니다. 각 모듈별로 학습 목표와 주요 학습 내용을 담고 있으니, 이 순서대로 차근차근 따라가 보세요."}},"previous":{"fields":{"slug":"/hello-world/"},"frontmatter":{"title":"Hello World"}},"next":{"fields":{"slug":"/클로저의 활용/"},"frontmatter":{"title":"클로저 입문 및 활용 정리"}}},"pageContext":{"id":"4985cca8-49eb-58cd-aea6-ae8d740e7aa8","previousPostId":"968c5589-e80a-51c8-b603-755f45eb82f0","nextPostId":"1e2016b1-9430-5c5a-98aa-136a85505c2a"}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}